<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComposableArchitecture - Effect</title>
    <link rel="stylesheet" type="text/css" href="/reactiveswift-composable-architecture/all.css" media="all" />
</head>
<body>
    <header>
        <a href="/reactiveswift-composable-architecture/">
            <strong>
                ComposableArchitecture
            </strong>
            <span>Documentation</span>
        </a>
        <sup>Beta</sup>
    </header>

    <!--
    <form class="search">
        <input type="search" placeholder="Search" />
    </form>
    -->

    <nav>
        <div class="wrapper">
            <h2>On This Page</h2>
            <ol><li><a href="#properties">Properties</a><ul><li class="variable"><a href="#effect.none">none</a></li></ul></li><li><a href="#methods">Methods</a><ul><li class="function"><a href="#effect.fireandforget(_:)">fire​And​Forget(_:​)</a></li><li class="function"><a href="#effect.concatenate(_:)">concatenate(_:​)</a></li><li class="function"><a href="#effect.concatenate(_:)">concatenate(_:​)</a></li><li class="function"><a href="#effect.deferred(_:)">deferred(_:​)</a></li><li class="function"><a href="#effect.future(_:)">future(_:​)</a></li><li class="function"><a href="#effect.catchtoeffect()">catch​ToEffect()</a></li><li class="function"><a href="#effect.fireandforget(outputtype:failuretype:)">fire​And​Forget(output​Type:​failure​Type:​)</a></li><li class="function"><a href="#effect.assign(to:on:)">assign(to:​on:​)</a></li><li class="function"><a href="#effect.cancellable(id:cancelinflight:)">cancellable(id:​cancel​InFlight:​)</a></li><li class="function"><a href="#effect.cancel(id:)">cancel(id:​)</a></li><li class="function"><a href="#effect.timer(id:every:tolerance:on:)">timer(id:​every:​tolerance:​on:​)</a></li><li class="function"><a href="#effect.debounce(id:interval:scheduler:)">debounce(id:​interval:​scheduler:​)</a></li></ul></li></ol>
        </div>
    </nav>

    <main>
        <article>
            <h1>
    <small>Extensions on</small>
    <code class="name">Effect</code>
</h1>
    <section id="properties">
        <h2>Properties</h2>

        <div role="article" class="variable" id="effect.none">
    <h3>
        <code>none</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="variable">none</span>: <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>An effect that does nothing and completes immediately. Useful for situations where you must
return an effect, but you don't need to do anything.</p>

</div>
</div>
    </section>
    <section id="methods">
        <h2>Methods</h2>

        <div role="article" class="function" id="effect.fireandforget(_:)">
    <h3>
        <code>fire​And​Forget(_:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">fireAndForget</span>(<span class="keyword">_</span> <span class="variable">work</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Creates an effect that executes some work in the real world that doesn't need to feed data
back into the store.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>work</th>
    <td><code class="type">@escaping () -&gt; Void</code></td>
    <td><p>A closure encapsulating some work to execute in the real world.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect.</p>

</div>
<div role="article" class="function" id="effect.concatenate(_:)">
    <h3>
        <code>concatenate(_:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">concatenate</span>(<span class="keyword">_</span> <span class="variable">effects</span>: <span class="type">Effect</span>...) -&gt; <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Concatenates a variadic list of effects together into a single effect, which runs the effects
one after the other.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>effects</th>
    <td><code class="type">Effect</code></td>
    <td><p>A variadic list of effects.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect</p>

</div>
<div role="article" class="function" id="effect.concatenate(_:)">
    <h3>
        <code>concatenate(_:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">concatenate</span>&lt;<span class="variable">C</span>: <span class="type">Collection</span>&gt;(
    <span class="keyword">_</span> <span class="variable">effects</span>: <span class="type">C</span>
  ) -&gt; <span class="type">Effect</span> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Concatenates a collection of effects together into a single effect, which runs the effects one
after the other.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>effects</th>
    <td><code class="type">C</code></td>
    <td><p>A collection of effects.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect</p>

</div>
<div role="article" class="function" id="effect.deferred(_:)">
    <h3>
        <code>deferred(_:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">deferred</span>(<span class="keyword">_</span> <span class="variable">createProducer</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">Value</span>, <span class="type">Error</span>&gt;)
    -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">Value</span>, <span class="type">Error</span>&gt;</code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>An Effect that waits until it is started before running
the supplied closure to create a new Effect, whose values
are then sent to the subscriber of this effect.</p>

</div>
</div>
<div role="article" class="function" id="effect.future(_:)">
    <h3>
        <code>future(_:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">future</span>(
    <span class="keyword">_</span> <span class="variable">attemptToFulfill</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Result</span>&lt;<span class="type">Value</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Creates an effect that can supply a single value asynchronously in the future.</p>

</div>
<div class="discussion">
    <p>This can be helpful for converting APIs that are callback-based into ones that deal with
<code>Effect</code>s.</p>

<p>For example, to create an effect that delivers an integer after waiting a second:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;.<span class="variable">future</span> { <span class="variable">callback</span> <span class="keyword">in</span>
  <span class="variable">DispatchQueue</span>.<span class="variable">main</span>.<span class="variable">asyncAfter</span>(<span class="variable">deadline</span>: .<span class="variable">now</span>() + <span class="number literal">1</span>) {
    <span class="variable">callback</span>(.<span class="variable">success</span>(<span class="number literal">42</span>))
  }
}
</code></pre></body></html>
<p>Note that you can only deliver a single value to the <code>callback</code>. If you send more they will be
discarded:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;.<span class="variable">future</span> { <span class="variable">callback</span> <span class="keyword">in</span>
  <span class="variable">DispatchQueue</span>.<span class="variable">main</span>.<span class="variable">asyncAfter</span>(<span class="variable">deadline</span>: .<span class="variable">now</span>() + <span class="number literal">1</span>) {
    <span class="variable">callback</span>(.<span class="variable">success</span>(<span class="number literal">42</span>))
    <span class="variable">callback</span>(.<span class="variable">success</span>(<span class="number literal">1729</span>)) <span class="comment">// Will not be emitted by the effect</span>
  }
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>attempt​ToFulfill</th>
    <td><code class="type">@escaping (@escaping (Result&lt;Value, Error&gt;) -&gt; Void) -&gt; Void</code></td>
    <td><p>A closure that takes a <code>callback</code> as an argument which can be used to feed it <code>Result&lt;Output, Failure&gt;</code> values.</p>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="function" id="effect.catchtoeffect()">
    <h3>
        <code>catch​ToEffect()</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">catchToEffect</span>() -&gt; <span class="type">Effect</span>&lt;<span class="type">Result</span>&lt;<span class="type">Value</span>, <span class="type">Error</span>&gt;, <span class="type">Never</span>&gt; </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Turns any producer into an <code>Effect</code> that cannot fail by wrapping its output and failure in a
result.</p>

</div>
<div class="discussion">
    <p>This can be useful when you are working with a failing API but want to deliver its data to an
action that handles both success and failure.</p>

<html><body><pre class="highlight"><code><span class="keyword">case</span> .<span class="variable">buttonTapped</span>:
  <span class="keyword">return</span> <span class="variable">fetchUser</span>(<span class="variable">id</span>: <span class="number literal">1</span>)
    .<span class="variable">catchToEffect</span>()
    .<span class="variable">map</span>(<span class="variable">ProfileAction</span>.<span class="variable">userResponse</span>)
</code></pre></body></html>
</div>
  <h4>Returns</h4>
  <p>An effect that wraps <code>self</code>.</p>

</div>
<div role="article" class="function" id="effect.fireandforget(outputtype:failuretype:)">
    <h3>
        <code>fire​And​Forget(output​Type:​failure​Type:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">fireAndForget</span>&lt;<span class="variable">NewValue</span>, <span class="variable">NewError</span>&gt;(
    <span class="variable">outputType</span>: <span class="type">NewValue</span>.<span class="type">Type</span> = <span class="variable">NewValue</span>.<span class="keyword">self</span>,
    <span class="variable">failureType</span>: <span class="type">NewError</span>.<span class="type">Type</span> = <span class="variable">NewError</span>.<span class="keyword">self</span>
  ) -&gt; <span class="type">Effect</span>&lt;<span class="type">NewValue</span>, <span class="type">NewError</span>&gt; </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Turns any publisher into an <code>Effect</code> for any output and failure type by ignoring all output
and any failure.</p>

</div>
<div class="discussion">
    <p>This is useful for times you want to fire off an effect but don't want to feed any data back
into the system. It can automatically promote an effect to your reducer's domain.</p>

<html><body><pre class="highlight"><code><span class="keyword">case</span> .<span class="variable">buttonTapped</span>:
  <span class="keyword">return</span> <span class="variable">analyticsClient</span>.<span class="variable">track</span>(<span class="string literal">"Button Tapped"</span>)
    .<span class="variable">fireAndForget</span>()
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>output​Type</th>
    <td><code class="type">New​Value.​Type</code></td>
    <td><p>An output type.</p>
</td>
</tr>
<tr>
    <th>failure​Type</th>
    <td><code class="type">New​Error.​Type</code></td>
    <td><p>A failure type.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect that never produces output or errors.</p>

</div>
<div role="article" class="function" id="effect.assign(to:on:)">
    <h3>
        <code>assign(to:​on:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="attribute">@</span><span class="attribute">discardableResult</span>
  <span class="keyword">public</span> <span class="keyword">func</span> <span class="function">assign</span>&lt;<span class="variable">Root</span>&gt;(<span class="variable">to</span> <span class="variable">keyPath</span>: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">Root</span>, <span class="keyword">Self</span>.<span class="type">Value</span>&gt;, <span class="variable">on</span> <span class="variable">object</span>: <span class="type">Root</span>)
    -&gt; <span class="type">Disposable</span></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Assigns each element from an Effect to a property on an object.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>key​Path</th>
    <td><code class="type">Reference​Writable​Key​Path&lt;Root, Self.​Value&gt;</code></td>
    <td><p>The key path of the property to assign.</p>
</td>
</tr>
<tr>
    <th>object</th>
    <td><code class="type">Root</code></td>
    <td><p>The object on which to assign the value.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable instance</p>

</div>
<div role="article" class="function" id="effect.cancellable(id:cancelinflight:)">
    <h3>
        <code>cancellable(id:​cancel​InFlight:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">cancellable</span>(<span class="variable">id</span>: <span class="type">AnyHashable</span>, <span class="variable">cancelInFlight</span>: <span class="type">Bool</span> = <span class="keyword">false</span>) -&gt; <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Turns an effect into one that is capable of being canceled.</p>

</div>
<div class="discussion">
    <p>To turn an effect into a cancellable one you must provide an identifier, which is used in
<code>Effect.cancel(id:)</code> to identify which in-flight effect should be canceled. Any hashable
value can be used for the identifier, such as a string, but you can add a bit of protection
against typos by defining a new type that conforms to <code>Hashable</code>, such as an empty struct:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">LoadUserId</span>: <span class="type">Hashable</span> {}

<span class="keyword">case</span> .<span class="variable">reloadButtonTapped</span>:
  <span class="comment">// Start a new effect to load the user</span>
  <span class="keyword">return</span> <span class="variable">environment</span>.<span class="variable">loadUser</span>
    .<span class="variable">map</span>(<span class="variable">Action</span>.<span class="variable">userResponse</span>)
    .<span class="variable">cancellable</span>(<span class="variable">id</span>: <span class="type">LoadUserId</span>(), <span class="variable">cancelInFlight</span>: <span class="keyword">true</span>)

<span class="keyword">case</span> .<span class="variable">cancelButtonTapped</span>:
  <span class="comment">// Cancel any in-flight requests to load the user</span>
  <span class="keyword">return</span> .<span class="variable">cancel</span>(<span class="variable">id</span>: <span class="type">LoadUserId</span>())
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td>
    <td><p>The effect's identifier.</p>
</td>
</tr>
<tr>
    <th>cancel​InFlight</th>
    <td><code class="type">Bool</code></td>
    <td><p>Determines if any in-flight effect with the same identifier should be canceled before starting this new one.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect that is capable of being canceled by an identifier.</p>

</div>
<div role="article" class="function" id="effect.cancel(id:)">
    <h3>
        <code>cancel(id:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">cancel</span>(<span class="variable">id</span>: <span class="type">AnyHashable</span>) -&gt; <span class="type">Effect</span> </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>An effect that will cancel any currently in-flight effect with the given identifier.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td>
    <td><p>An effect identifier.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect that will cancel any currently in-flight effect with the given identifier.</p>

</div>
<div role="article" class="function" id="effect.timer(id:every:tolerance:on:)">
    <h3>
        <code>timer(id:​every:​tolerance:​on:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">timer</span>(
    <span class="variable">id</span>: <span class="type">AnyHashable</span>,
    <span class="variable">every</span> <span class="variable">interval</span>: <span class="type">DispatchTimeInterval</span>,
    <span class="variable">tolerance</span>: <span class="type">DispatchTimeInterval</span>? = <span class="keyword">nil</span>,
    <span class="variable">on</span> <span class="variable">scheduler</span>: <span class="type">DateScheduler</span>
  ) -&gt; <span class="type">Effect</span>&lt;<span class="type">Value</span>, <span class="type">Error</span>&gt; </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Returns an effect that repeatedly emits the current time of the given scheduler on the given
interval.</p>

</div>
<div class="discussion">
    <p>This is basically a wrapper around the ReactiveSwift <code>SignalProducer.timer</code> function
and which adds the the ability to be cancelled via the <code>id</code>.</p>

<p>To start and stop a timer in your feature you can create the timer effect from an action
and then use the <code>.cancel(id:)</code> effect to stop the timer:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">AppState</span> {
  <span class="keyword">var</span> <span class="variable">count</span> = <span class="number literal">0</span>
}

<span class="keyword">enum</span> <span class="type">AppAction</span> {
  <span class="keyword">case</span> <span class="variable">startButtonTapped</span>, <span class="variable">stopButtonTapped</span>, <span class="variable">timerTicked</span>
}

<span class="keyword">struct</span> <span class="type">AppEnvironment</span> {
  <span class="keyword">var</span> <span class="variable">mainQueue</span>: <span class="type">AnySchedulerOf</span>&lt;<span class="type">DispatchQueue</span>&gt;
}

<span class="keyword">let</span> <span class="variable">appReducer</span> = <span class="variable">Reducer</span>&lt;<span class="type">AppState</span>, <span class="type">AppAction</span>, <span class="type">AppEnvironment</span>&gt; { <span class="variable">state</span>, <span class="variable">action</span>, <span class="variable">env</span> <span class="keyword">in</span>
  <span class="keyword">struct</span> <span class="type">TimerId</span>: <span class="type">Hashable</span> {}

  <span class="keyword">switch</span> <span class="variable">action</span> {
  <span class="keyword">case</span> .<span class="variable">startButtonTapped</span>:
    <span class="keyword">return</span> <span class="variable">Effect</span>.<span class="variable">timer</span>(<span class="variable">id</span>: <span class="type">TimerId</span>(), <span class="variable">every</span>: <span class="number literal">1</span>, <span class="variable">on</span>: <span class="type">env</span>.<span class="variable">mainQueue</span>)
      .<span class="variable">map</span> { <span class="keyword">_</span> <span class="keyword">in</span> .<span class="variable">timerTicked</span> }

  <span class="keyword">case</span> .<span class="variable">stopButtonTapped</span>:
    <span class="keyword">return</span> .<span class="variable">cancel</span>(<span class="variable">id</span>: <span class="type">TimerId</span>())

  <span class="keyword">case</span> <span class="keyword">let</span> .<span class="variable">timerTicked</span>:
    <span class="type">state</span>.<span class="variable">count</span> += <span class="number literal">1</span>
    <span class="keyword">return</span> .<span class="variable">none</span>
}
</code></pre></body></html>
<p>Then to test the timer in this feature you can use a test scheduler to advance time:</p>

<p>func testTimer() {
let scheduler = TestScheduler()</p>

<html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">store</span> = <span class="variable">TestStore</span>(
  <span class="variable">initialState</span>: .<span class="variable">init</span>(),
  <span class="variable">reducer</span>: <span class="type">appReducer</span>,
  <span class="variable">envirnoment</span>: .<span class="variable">init</span>(
    <span class="variable">mainQueue</span>: <span class="type">scheduler</span>
  )
)

<span class="variable">store</span>.<span class="variable">send</span>(.<span class="variable">startButtonTapped</span>)

<span class="variable">scheduler</span>.<span class="variable">advance</span>(<span class="variable">by</span>: .<span class="variable">seconds</span>(<span class="number literal">1</span>))
<span class="variable">store</span>.<span class="variable">receive</span>(.<span class="variable">timerTicked</span>) { <span class="variable">$0</span>.<span class="variable">count</span> = <span class="number literal">1</span> }

<span class="variable">scheduler</span>.<span class="variable">advance</span>(<span class="variable">by</span>: .<span class="variable">seconds</span>(<span class="number literal">5</span>))
<span class="variable">store</span>.<span class="variable">receive</span>(.<span class="variable">timerTicked</span>) { <span class="variable">$0</span>.<span class="variable">count</span> = <span class="number literal">2</span> }
<span class="variable">store</span>.<span class="variable">receive</span>(.<span class="variable">timerTicked</span>) { <span class="variable">$0</span>.<span class="variable">count</span> = <span class="number literal">3</span> }
<span class="variable">store</span>.<span class="variable">receive</span>(.<span class="variable">timerTicked</span>) { <span class="variable">$0</span>.<span class="variable">count</span> = <span class="number literal">4</span> }
<span class="variable">store</span>.<span class="variable">receive</span>(.<span class="variable">timerTicked</span>) { <span class="variable">$0</span>.<span class="variable">count</span> = <span class="number literal">5</span> }
<span class="variable">store</span>.<span class="variable">receive</span>(.<span class="variable">timerTicked</span>) { <span class="variable">$0</span>.<span class="variable">count</span> = <span class="number literal">6</span> }

<span class="variable">store</span>.<span class="variable">send</span>(.<span class="variable">stopButtonTapped</span>)
</code></pre></body></html>
<p>}</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>interval</th>
    <td><code class="type">Dispatch​Time​Interval</code></td>
    <td><p>The time interval on which to publish events. For example, a value of <code>0.5</code> publishes an event approximately every half-second.</p>
</td>
</tr>
<tr>
    <th>scheduler</th>
    <td><code class="type">Date​Scheduler</code></td>
    <td><p>The scheduler on which the timer runs.</p>
</td>
</tr>
<tr>
    <th>tolerance</th>
    <td><code class="type">Dispatch​Time​Interval?</code></td>
    <td><p>The allowed timing variance when emitting events. Defaults to <code>nil</code>, which allows any variance.</p>
</td>
</tr>
<tr>
    <th>options</th>
    <td></td>
    <td><p>Scheduler options passed to the timer. Defaults to <code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="function" id="effect.debounce(id:interval:scheduler:)">
    <h3>
        <code>debounce(id:​interval:​scheduler:​)</code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">debounce</span>(
    <span class="variable">id</span>: <span class="type">AnyHashable</span>,
    <span class="variable">interval</span>: <span class="type">TimeInterval</span>,
    <span class="variable">scheduler</span>: <span class="type">DateScheduler</span>
  ) -&gt; <span class="type">Effect</span>&lt;<span class="type">Value</span>, <span class="type">Error</span>&gt; </code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Turns an effect into one that can be debounced.</p>

</div>
<div class="discussion">
    <p>To turn an effect into a debounce-able one you must provide an identifier, which is used to
determine which in-flight effect should be canceled in order to start a new effect. Any
hashable value can be used for the identifier, such as a string, but you can add a bit of
protection against typos by defining a new type that conforms to <code>Hashable</code>, such as an empty
struct:</p>

<html><body><pre class="highlight"><code><span class="keyword">case</span> <span class="keyword">let</span> .<span class="variable">textChanged</span>(<span class="variable">text</span>):
  <span class="keyword">struct</span> <span class="type">SearchId</span>: <span class="type">Hashable</span> {}

  <span class="keyword">return</span> <span class="variable">environment</span>.<span class="variable">search</span>(<span class="variable">text</span>)
    .<span class="variable">map</span>(<span class="variable">Action</span>.<span class="variable">searchResponse</span>)
    .<span class="variable">debounce</span>(<span class="variable">id</span>: <span class="type">SearchId</span>(), <span class="variable">for</span>: <span class="number literal">0.5</span>, <span class="variable">scheduler</span>: <span class="type">environment</span>.<span class="variable">mainQueue</span>)
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td>
    <td><p>The effect's identifier.</p>
</td>
</tr>
<tr>
    <th>due​Time</th>
    <td></td>
    <td><p>The duration you want to debounce for.</p>
</td>
</tr>
<tr>
    <th>scheduler</th>
    <td><code class="type">Date​Scheduler</code></td>
    <td><p>The scheduler you want to deliver the debounced output to.</p>
</td>
</tr>
<tr>
    <th>options</th>
    <td></td>
    <td><p>Scheduler options that customize the effect's delivery of elements.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect that publishes events only after a specified time elapses.</p>

</div>
    </section>
        </article>
    </main>

    <footer>
        <p>
    Generated on <time datetime="2021-04-27T09:43:54+0000">April 27, 2021</time> using <a href="https://github.com/SwiftDocOrg/swift-doc">swift-doc</a> <span class="version">1.0.0-beta.6</span>.
</p>
    </footer>
</body>
</html>
